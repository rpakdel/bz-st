import pandas as pd
import networkx as nx
from parsers.block_model import parse_blocks_file
from parsers.precedence import parse_precedence_file
from parsers.optimization import parse_optimization_file
from models.bz_controller import BZController


def load_zuck_subset(n_blocks=200):
    base = "data/minelib/zuck_small"
    blocks_file = f"{base}/zuck_small.blocks"
    prec_file = f"{base}/zuck_small.prec"
    upit_file = f"{base}/zuck_small.upit"

    bm = parse_blocks_file(blocks_file)
    pm = parse_precedence_file(prec_file)
    om = parse_optimization_file(upit_file)

    # Create a small subset of block ids [0..n_blocks-1]
    subset_ids = list(range(min(n_blocks, len(bm.blocks))))

    # Build precedence subgraph including edges where both nodes are in subset
    G_full = pm.to_networkx()
    G = nx.DiGraph()
    G.add_nodes_from(subset_ids)
    for u, v in G_full.edges():
        if u in subset_ids and v in subset_ids:
            G.add_edge(u, v)

    # Build profits mapping from optimization model (first destination)
    profits = {i: om.objective.get(i, [0.0])[0] for i in subset_ids}

    return bm, pm, om, G, profits


def test_zuck_small_controller_subset():
    bm, pm, om, G, profits = load_zuck_subset(n_blocks=200)

    controller = BZController(n_blocks=200, precedence_graph=G, profits=profits, max_iters=20, max_columns=200)
    # Seed with top-k profitable singletons
    controller.seed_with_singletons(topk=10)

    res = controller.run()

    # Ensure we either converged or reached max_iters (but didn't error)
    assert res["status"] in ("converged", "max_iters", "max_columns_reached")

    # Verify closure property for patterns generated by the pricer (names starting with 'col_')
    Gsucc = G
    for p in controller.master.columns:
        if not getattr(p, 'name', '').startswith('col_'):
            continue
        for b in p.blocks:
            # All predecessors of b in G should also be in p.blocks
            preds = list(nx.ancestors(Gsucc, b))
            for pred in preds:
                if pred in Gsucc.nodes():
                    assert pred in p.blocks

    # If controller reports converged, the last reduced cost should be >= -eps (i.e., no improving column)
    history = controller.get_history()
    if res["status"] == "converged":
        assert history, "history should exist when converged"
        last = history[-1]
        assert last['reduced_cost'] >= -controller.eps - 1e-12
